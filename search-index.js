var searchIndex = JSON.parse('{\
"xor_name":{"doc":"xor_name","t":[12,3,17,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,14],"n":["0","Prefix","XOR_NAME_LEN","XorName","ancestor","ancestors","as_ref","as_ref","bit","bit_count","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","cmp","cmp","cmp_breadth_first","cmp_distance","cmp_distance","common_prefix","default","default","deref","deserialize","deserialize","eq","eq","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from_content","from_content_parts","from_str","hash","hash","into","into","is_compatible","is_covered_by","is_empty","is_extension_of","is_neighbour","lower_bound","matches","name","ne","new","not","partial_cmp","partial_cmp","popped","pushed","random","range_inclusive","serialize","serialize","sibling","substituted_in","to_owned","to_owned","to_string","try_from","try_from","try_into","try_into","type_id","type_id","upper_bound","vzip","vzip","with_bit","with_flipped_bit","xor_name"],"q":["xor_name","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["","A section prefix, i.e. a sequence of bits specifying the …","Constant byte length of <code>XorName</code>.","A 256-bit number, viewed as a point in XOR space.","Returns the ancestors of this prefix that has the given …","Returns an iterator that yields all ancestors of this …","","","Returns <code>true</code> if the <code>i</code>-th bit is <code>1</code>.","Returns the number of bits in the prefix.","","","","","","","","","","","Compares the prefixes using breadth-first order. That is, …","Compares the distance of <code>self</code> and <code>other</code> to <code>target</code>. …","Compares the distance of the arguments to <code>self</code>. Returns …","Returns the number of common leading bits with the input …","","","","","","","","","","","","","","","","","Generate a XorName for the given content.","Generate a XorName for the given content (for …","","","","","","Returns <code>true</code> if <code>self</code> is a prefix of <code>other</code> or vice versa.","Returns whether the namespace defined by <code>self</code> is covered …","Returns <code>true</code> if this is the empty prefix, with no bits.","Returns <code>true</code> if <code>other</code> is compatible but strictly shorter …","Returns <code>true</code> if the <code>other</code> prefix differs in exactly one …","Returns the smallest name matching the prefix","Returns <code>true</code> if this is a prefix of the given <code>name</code>.","Returns the name of this prefix.","","Creates a new <code>Prefix</code> with the first <code>bit_count</code> bits of <code>name</code>…","","","","Returns a prefix copying the first <code>bitcount() - 1</code> bits …","Returns <code>self</code> with an appended bit: <code>0</code> if <code>bit</code> is <code>false</code>, and …","Generate a random XorName","Inclusive range from lower_bound to upper_bound","","","Returns the same prefix, with the last bit flipped, or …","Returns the given <code>name</code> with first bits replaced by <code>self</code>","","","","","","","","","","Returns the largest name matching the prefix","","","Returns a copy of <code>self</code>, with the <code>i</code>-th bit set to <code>bit</code>.","Returns the neighbouring prefix differing in the <code>i</code>-th bit …","Creates XorName with the given leading bytes and the rest …"],"i":[1,0,0,0,2,2,1,1,1,2,2,1,2,1,2,1,2,1,2,1,2,2,1,2,2,1,1,2,1,2,1,2,2,1,1,1,1,1,2,1,1,1,2,2,1,2,1,2,2,2,2,2,2,2,2,1,2,1,2,1,2,2,1,2,2,1,2,2,2,1,1,2,1,2,1,2,1,2,2,1,1,2,0],"f":[null,null,null,null,[[["u8",15]]],[[],["ancestors",3]],[[]],[[]],[[["u8",15]],["bool",15]],[[],["usize",15]],[[]],[[]],[[]],[[]],[[],["prefix",3]],[[],["xorname",3]],[[]],[[]],[[],["ordering",4]],[[["xorname",3]],["ordering",4]],[[],["ordering",4]],[[["xorname",3]],["ordering",4]],[[],["ordering",4]],[[["xorname",3]],["usize",15]],[[],["prefix",3]],[[],["xorname",3]],[[]],[[],["result",4]],[[],["result",4]],[[],["bool",15]],[[["xorname",3]],["bool",15]],[[["formatter",3]],["fmtresult",6]],[[["formatter",3]],["fmtresult",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[["str",15]],["result",4]],[[]],[[]],[[]],[[]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["xorname",3]],[[["xorname",3]],["bool",15]],[[],["xorname",3]],[[["xorname",3]],["bool",15]],[[["xorname",3],["usize",15]]],[[]],[[],[["option",4],["ordering",4]]],[[["xorname",3]],[["option",4],["ordering",4]]],[[]],[[["bool",15]]],[[]],[[],[["xorname",3],["rangeinclusive",3]]],[[],["result",4]],[[],["result",4]],[[]],[[["xorname",3]],["xorname",3]],[[]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["xorname",3]],[[]],[[]],[[["bool",15],["u8",15]]],[[["u8",15]]],null],"p":[[3,"XorName"],[3,"Prefix"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};